# Work Effort: Traffic Control Layer (Nova System Intelligence Upgrade)

## Status: Completed
**Started:** 2025-12-06 14:40
**Last Updated:** 2025-12-06 14:55

## Objective
Implement a "Traffic Control" layer to manage Costs and Rate Limits, and prepare the architecture for Long-Term Memory. This transforms the MVP from a simple wrapper into a managed system with cost-awareness and stability.

## Architecture Overview

### Feature A: The "Ledger" (Cost Projection)
**File:** `nova-mvp/backend/core/pricing.py`
- `CostEstimator` class for offline cost calculation
- Uses heuristic: 1 token ‚âà 4 characters
- Supports Gemini pricing tiers (per 1M tokens):
  - Gemini 2.5 Flash: Input $0.10 / Output $0.40
  - Gemini 2.5 Flash-Lite: Input $0.075 / Output $0.30
  - Gemini 3 Pro Preview: Input $2.00 / Output $12.00
  - Gemini 2.5 Pro: Input $1.25 / Output $10.00
  - Imagen 3 (Fast): $0.03 per image (fixed)

### Feature B: Traffic Control (Rate Limiting)
**File:** `nova-mvp/backend/core/traffic.py`
- `TrafficController` class with sliding window tracking
- Tracks RPM (Requests Per Minute) and TPM (Tokens Per Minute)
- Default Tier 1 Limits:
  - Gemini 2.5 Flash: ~15 RPM / 1M TPM
  - Gemini 3 Pro: 2 RPM / 32k TPM (restrictive preview)
- Raises `RateLimitExceeded` exception with `retry_after` value

### Feature C: Memory Stub (Embeddings Architecture)
**File:** `nova-mvp/backend/core/memory.py`
- Abstract `VectorStore` interface
- Target: `gemini-embedding-001` (768 dimensions)
- Methods: `embed_text()`, `add_document()`, `search()`

## Tasks
1. [x] Create work effort documentation
2. [x] Create `pricing.py` - CostEstimator with Gemini pricing
3. [x] Create `traffic.py` - TrafficController with RPM/TPM tracking
4. [x] Create `memory.py` - VectorStore abstract interface
5. [x] Update `core/__init__.py` - Export new modules
6. [x] Integrate TrafficController into `llm.py`
7. [x] Add `/api/check-status` endpoint to `routes.py`
8. [x] Add pre-flight checks to CLI `nova.py`
9. [x] Update devlog with session notes
10. [x] Test end-to-end flow (all modules verified working)

## Acceptance Criteria
1. **Safety:** System never crashes on 429 errors; waits or warns beforehand
2. **Transparency:** Users see exact cost before running Gemini 3 Pro
3. **Accuracy:** Pricing matches Gemini "Paid Tier" documentation
4. **Architecture:** Modular code (`pricing.py`, `traffic.py`) not hardcoded

## Integration Points

### CLI Pre-Flight Check
Before spinner starts:
1. Call `CostEstimator` ‚Üí Print: `üí∞ Est. Cost: $0.0004 | Tokens: 154`
2. Call `TrafficController` ‚Üí If blocked: `‚è≥ Rate Limit Reached. Cooldown: 14s...`

### API Endpoint
`POST /api/check-status`:
- Accepts: `prompt`, `model`
- Returns: `{ "cost_estimate": ..., "rate_limit_status": "ok" | "blocked" }`

## Progress
- Created work effort documentation
- Implemented `pricing.py` with full Gemini pricing tiers
- Implemented `traffic.py` with sliding window rate limiting
- Implemented `memory.py` with VectorStore interface + stub
- Updated `__init__.py` to export all new modules
- Integrated TrafficController into all LLM providers
- Added `/api/check-status`, `/api/rate-limits/{model}`, `/api/pricing` endpoints
- Added pre-flight checks to CLI with cost/rate-limit display
- Added `/cost` and `/preflight` commands to interactive mode
- Created devlog entry

## Next Steps
1. Test end-to-end flow with real API calls
2. Implement actual vector store (ChromaDB) when needed
3. Add persistent rate limit tracking (Redis) for production

## Notes
- Uses sliding window for rate limit tracking (not token bucket)
- Memory stub is placeholder for future RAG system
- All pricing in USD

## Related Documents
- [[01.01_nova_mvp_development]] - Nova MVP Development (parent work effort)
